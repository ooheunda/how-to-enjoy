## 의문점 호이스팅
- 누군가 <a href="https://ko.wikipedia.org/wiki/%EB%93%9C_%EB%AA%A8%EB%A5%B4%EA%B0%84%EC%9D%98_%EB%B2%95%EC%B9%99">드 모르간의 법칙</a>을 설명해주었으면 좋겠다네요.
# 6장 데이터 타입
### 6.1 숫자 타입
  C나 자바의 경우엔 정수와 실수를 구분해 `int`, `long`, `float`, `double` 등과 같은 다양한 숫자 타입을 제공하지만 자바스크립트는 하나의 숫자 타입만 존재한다.  
  모든 수를 실수로 처리하며, 2진수, 8진수, 16진수 리터럴은 모두 2진수로 저장되기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.  
  - Infinity: 양의 무한대
  - -Infinity: 음의 무한대
  - NaN: 산술 연산 불가(Not-a-Number)  
  놀랍게도 이들도 숫자라고 한다.

### 6.2 문자열 타입 
  키워드나 식별자 같은 토큰과 구분하기 위해 큰 따옴표`""`, 작은 따옴표`''`, 백틱` `` ` 으로 감싸 문자열을 표현한다.  
  자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값(immutable value)이다.
  
### 6.3 템플릿 리터럴
  백틱` `` `을 사용해 표현한다. 이스케이프 시퀀스를 사용하지 않아도 개행이 허용되며 모든 공백이 적용된다. 또한 `${}`를 이용해 표현식을 삽입할 수도 있다.  
  - 라인 피드와 캐리지 리턴  
    운영체제별로 다른 개행 방식. 윈도우는 CR+LF, 리눅스는 LF, macOS는 버전 10 이전엔 CR을, 이후엔 LF를 사용한다.  
    따라서 다른 운영체제에서 작성한 텍스트 파일은 서로 개행 문자를 인식하지 못한다. 다만 대부분의 텍스트 에디터는 이를 자동 변환해주므로 크게 문제가 되진 않는다.
    
### 6.4 불리언 타입
  논리적 참, 거짓을 나타내는 true, false뿐이다.
  
### 6.5 undefined 타입
  `var` 로 선언한 변수는 암묵적으로 undefined로 초기화된다. 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 비어 있지 않고 쓰레기 값이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화한다.  
  
### 6.6 null 타입
  변수에 null을 할당한다는 것은 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.  

### 6.7 심벌 타입 
  `Symbol` 함수를 호출해 생성하는 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값으로, 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.  

### 6.8 객체 타입 
  자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다. 11장에서 자세한 설명이 이어진다.  

### 6.9 데이터 타입의 필요성 
  1. 데이터 타입에 의한 메모리 공간의 확보와 참조  
    자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.  
  2. 데이터 타입에 의한 값의 해석  
    모든 값은 데이터 타입을 가지며 메모리에 2진수, 즉 비트의 나열로 저장된다. 이 비트의 나열을 읽기 위해선 데이터 타입이 필요하다.  

### 6.10 동적 타이핑 
  정적 타입 언어는 변수를 선언할 때 데이터 타입도 같이 지정해야 하며 바꿀 수 없다. 컴파일 시점에 **타입 체크**(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다.  
  동적 타입 언어는 변수 선언 시에도 데이터 타입을 지정할 필요가 없고, 변경도 자유롭다. `typeof` 연산자를 이용해 타입을 확인할 수 있다.  
  기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다. 따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절하다. 변수는 값에 묶여 있는 값에 대한 별명이기 때문이다.  
  - **주의할 점**
    - 변수의 무분별한 남발은 금물. 필요한 만큼 최소한으로 유지
    - 변수의 유효 범위(스코프)는 최대한 좁게 만들어 부작용 억제
    - 전역 변수는 최대한 사용하지 않도록 한다.
    - 변수보다는 상수를 사용
    - 개발자의 의도를 나타내는 명확한 네이밍
  
***결론: 가독성이 좋은 코드가 좋은 코드다.***

# 7장 연산자
### 7.1 산술 연산자
- 이항 산술 연산자 `+` `-` `*` `/` `%`
- 단항 산술 연산자 `++` `--` `+` `-`
  - 숫자 타입이 아닌 피연산자에 `+` 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환하는데, 이때 피연산자를 변경하는 것이 아니라 숫자 타입으로 변환한 값을 생성해서 반환한다.
  - 전위 증가/감소 연산자: 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.
  - 후위 증가/감소 연산자: 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.
    ```
    let x = 1, result;
    // x라는 변수를 선언함과 동시에 1 할당, result라는 변수 선언 (쉼표 연산자)
    
    result = x++;
    console.log(result, x); //1, 2
    
    result = ++x;
    console.log(result, x); //3, 3
    ```
- 문자열 연결 연산자 `+`: 피연산자중 하나만 문자열이어도 문자열 연결 연산자로 동작한다.

### 7.2 할당 연산자
할당문은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.
```
let a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행
a = b = c = 0;

console.log(a, b, c); //0 0 0
```

### 7.3 비교 연산자
- 동등/일치 비교 연산자 `==`, `===`
  동등 비교 연산자 `==`는 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 일치 비교 연산자 `===`는 타입도 고려하여 비교한다.
  ```
  // 동등 비교. 결과가 지멋대로임
  '0' == ''; //false
  0 == ''; //true
  0 == '0'; //true
  false == null; //false
  false == undefined; //false
  ```
  - 일치 비교 연산자에서, `NaN`은 자신과 일치하지 않는 유일한 값이라 `NaN === NaN` 은 `false`이다.
    ```
    // 빌트인 함수를 사용하여 조사할 수 있다.
    Number.isNaN(NaN); //true
    Number.isNaN(1 + undefined); //true
    Nubmer.isNaN(10); //false
    ```
  - 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다. (뭔 개소리임)
    ```
    0 === -0; //true
    // Object.is 메서드 사용
    Object.is(-0, +0); //false
    Object.is(NaN, NaN); //true
    ```
- 대소 관계 비교 연산자 `<` `>` `<=` `>=`

### 7.4 삼항 조건 연산자
`조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값`  
조건식의 평가 결과가 불리언 타입이 아니면 암묵적으로 타입을 변환 한다.  
삼항 조건 연산자 표현식은 값으로 평가할 수 있는 **표현식인 문**이다. 따라서 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다.

### 7.5 논리 연산자
논리합 `||`, 논리곱 `&&`, 부정 `!`  
피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.  

### 7.6 쉼표 연산자 `,`

### 7.7 그룹 연산자
`()`. 연산자 우선순위가 가장 높다. (이것도 연산자라고 부르는지 몰랐음)

### 7.8 typeof 연산자
피연산자의 데이터 타입을 문자열로 반환한다. 그러나 typeof 연산자가 반환하는 문자열은 정확히 일치하지는 않는데, `null`을 typeof 연산자로 연산해보면 "object"를 반환한다. 또, 선언하지 않은 식별자를 typeof 연산자로 연산해보면 ReferenceError가 발생하지 않고 "undefined"를 반환한다.

### 7.9 지수 연산자
ES7에서 도입된 지수 연산자 `**`는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다. 이항 연산자 중에서 우선 순위가 가장 높다.
```
2 ** (3 ** 2); //2 ** 9 = 512
// ES7 이전에는 Math.pow 메서드를 사용했다.
Math.pow(2, Math.pow(3, 2)); // Math.pow(2, 9) = 512
```

### 7.10 그 외의 연산자
- 옵셔널 체이닝 연산자 `?`
- null 병합 연산자 `??`
- 프로퍼티 삭제 연산자 `delete`
- 생성자 함수를 호출할 때 사용하여 인스턴스를 생성하는 `new`
- 좌변의 객체과 우변의 생성자 함수와 연결된 인스턴스인지 판별하는 `instanceof`
- 프로퍼티 존재를 확인하는 `in`  
다른 장에서 추가 설명됨.

### 7.11 연산자의 부수 효과
부수 효과가 있는 연산자는 할당 연산자 `=`, 증가/감소 연산자 `++` `--`, `delete` 연산자다.

### 7.12 연산자 우선순위
우선순위가 높을수록 먼저 실행된다. 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것이 권장된다.

### 7.13 연산자 결합 순서

# 8장 제어문
### 8.1 블록문
0개 이상의 문을 중괄호로 묶은 것. 하나의 실행 단위로 취급된다.

### 8.2 조건문
불리언 값으로 평가될 수 있는 표현식이다. 평가된 값이 불리언 타입이 아니면 암묵적 타입 변환된다.
- `if-else` 문  
  대부분의 if-else문은 삼항 조건 연산자로 바꿔 쓸 수 있다. 단순히 값을 결정하여 변수에 할당하는 경우 삼항 조건 연산자를, 실행해야 할 내용이 복잡한 경우 if-else문을 사용하자.
- `switch` 문  
  if-else문은 논리적 참, 거짓으로 실행할 코드 블록을 결정하는데, switch문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.  
  fall through를 고려하여 `break` 키워드를 사용한 `break`문을 넣어주자.
  
### 8.3 반복문
- for문
- while문
- do-while문
for문은 반복 횟수가 명확할 때, while문은 반복 횟수가 불명확할 때 주로 사용한다.

### 8.4 break 문
코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 외에 break문을 사용하면 SyntaxError가 발생한다.  
- 레이블 문은 식별자가 붙은 문을 말한다. 중첩된 for문 외부로 탈출할 때 유용하지만 그 밖의 경우에는 일반적으로 권장되지 않는다.

### 8.5 continue 문
반복문의 코드 블록 실행을 현 지점에서 중단하고 증감식으로 실행 흐름을 이동시킨다. break문처럼 반복문을 탈출하지는 않는다.
