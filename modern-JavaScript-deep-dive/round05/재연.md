# 14장 전역 변수의 문제점

- 전역 변수는 더 이상 실행할 코드가 남아 있지 않을때까지 소멸되지 않는다.
- 즉, 소멸되지 않기 때문에 메모리 상에서도 소멸되기 전까지 계속해서 남아있는다.
- 지역 변수 또한 함수가 종료되기 전에는 소멸되지 않는다.
- 전역 변수와 지역 변수는 각각 호이스팅이 따로 적용된다.
- 전역 변수는 오류가 나기 쉽고, 디버깅 또한 어려워지기 때문에 최대한 억제해야한다.
- 억제하는 방법은 다음과 같다.
  1. 즉시 실행 함수
  2. 네임스페이스 객체 <- 네임스페이스 또한 전역 변수로 적용되기 때문에 효과적이진 않다.
  3. 모듈 패턴
  4. ES6 모듈
# 15장 let, const 키워드와 블록 레벨 스코프
- var의 특징은 해당 선언문이 호이스팅 되어 undefined값을 할당받는다
- 이때 해당 변수가 값을 할당받았을 때, 초기화 문이 없는 선언문은 무시된다.
- 전역에서 선언된 var는 블록 스코프에서 해당 var가 선언됐을 때 동일하게 전역변수가 된다.
- let과 const는 var와 다르게 선언 단계와 초기화 단계가 분리되어 진행된다.
- 만약 초기화 단계가 실행되기 이전에 변수에 접근 하려고 하면 리퍼런스 에러가 발생한다.
- 이러한 구간을 TDZ(Temporal Dead Zone)이라고 부른다.
- 그렇다고 let이 호이스팅이 되지 않는 것은 아니다.
# 16장 프로퍼티 어트리뷰트
- 프로퍼티 또한 직접 정의할 수 있다.
- Object.defineProperty 메소드를 사용하면 해당 프로퍼티의 어트리뷰트를 정의할 수 있다.
- 이 때, 디스크립터 객체의 프로퍼티를 누락시키면 기본적으로 false가 할당된다.
- Enumerable 값이 false인 경우, for...in 문이나 Object.keys 등으로 열거할 수 없다.
- Writable 값이 false인 경우, 해당 프로퍼티의 value값을 변경할 수 없다. 단, 에러는 발생하지 않고 해당 코드가 무시된다.
- Configurable 값이 false인 경우, 해당 프로퍼티를 삭제할 수 없다.
- freeze로 객체를 동결시키더라도 객체 내부에 있는 중첩 객체까지 동결시키는 것은 불가능하다.
# 17장 생성자 함수에 의한 객체 생성
- new 연산자와 함께 Object 생성자 함수를 사용하면 빈 객체를 생성하여 반환한다.
- 객체 리터럴에 의한 객체 생성 방식의 문제점은 재활용성이 전무하다는 것이다.
- 하지만 생성자 함수에 의한 객체를 생성하게 되면 인자를 받는 식으로 사용함으로써 재활용성이 높아진다.
- 생성자 함수를 호출하여 빈 객체가 생성됐을때 인스턴스는 this에 바인딩된다. 즉, 생성자 함수의 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유이다.
# 18장 함수와 일급 객체
- 함수가 일급 객체인 이유는 함수를 객체와 동일하게 사용할 수 있다는 것이다.
- 자바스크립트는 함수의 매개변수와 인수가 동일하지 확인하지 않는다.
```
function sum (a, b) {
  return x * y
}
```
질문 : 여기서 매개변수로 아무것도 전달하지 않았는데 NaN이 뜨는 이유는 *연산자를 사용해서 그런건지?
- ES6에서는 유사 배열 객체에서 배열 메서드를 사용하기 위해 ...(Rest) 파라미터를 사용할 수 있다.
- arguments 객체의 length는 인자의 개수를 가리키고, 함수 객체의 length는 매개변수의 개수를 가리킨다.
- name 프로퍼티는 함수 객체를 가리키는 식별자를 값으로 갖는다.
- 익명 함수 표현식에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.
- 
