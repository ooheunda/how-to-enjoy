# 14장 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

- 전역 변수의 생명 주기 = 애플리케이션의 생명 주기
- 지역 변수의 생명 주기 = 함수의 생명 주기

### 14.1.2 전역 변수의 생명 주기

- 실행할 문이 없을 때 종료
- 전역 객체
  - 어떤 객체 보다도 먼저 생성되는 특수한 객체. 브라우저=window 서버=global
- `var`로 선언한 번역 변수는 전역 객체의 생명 주기와 일치

## 14.2 전역 변수의 문제점

1. 암묵적 결함

- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용
- 변수의 스코프가 클수록 가독성은 나빠지고 의도치 않게 상태 변경.

2. 긴 생명주기

- 메모리 리소스 오랜 기간 소비

3. 스코프 체인 상 종점에 존재

- 마지막에 검색이 되므로 검색 속도가 가장 느림

4. 네임스페이스 오염

- 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 애에 존재할 경우 오류 발생

## 14.3 전역 변수의 사용을 억제하는 방법

### 14.3.1 즉시 실행 함수

- 함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출
- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```javascript
(function () {
  var foo = 10;
  // ..
})();
console.log(foo); // ReferenseError : foo is not undefined
```

- 라이브러리 등에 자주 사용

### 14.3.2 네임 스페이스 객체

- 전역에 네임 스페이스 역할을 담당하는 객체 생성 => 변수를 프로퍼티로 추가하는 방법

```javascript
var MYAPP = {};
MYAPP.name = "on";
console.log(MYAPP.name); // on
```

### 14.3.3 모듈 패턴

- 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 모듈로 만듦.
- 정보 은닉을 구현하기 위해 사용

```javascript
var Counter = (function(){
    // private
    var = num 0;
    // public
    return{
        increase() {
            return ++num
        }
        decrease(){
            return --num
        }
    }
}())
console.log(Counter.num) // undefined
```

### 14.3.4 ES6 모듈

- 파일 자체의 독자적인 모듈 스코프를 제공

```javascript
<script type='module' ...>
```

# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드 선언의 문제점

### 15.1.1 변수 중복선언 허용

- 중복선언이 가능하다 => 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용

### 15.1.2 함수 레벨 스코프

- 함수 외부에서 var키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

### 15.1.3 변수 호이스팅

- 변수 호이스팅에 의해 선언문 이전에 참조 할 수 있다. => 가독성을 떨어뜨리고 오류를 발생할 여지를 남김

## 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

### 15.2.2 블록 레벨 스코프

- let으로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.
- 함수 내의 코드블록은 함수 레벨 스코프에 중첩된다.

### 15.2.3 변수 호이스팅

- 선언 단계와 초기와 단계가 분리되어 실행. => 초기화는 변수 선언문에 도달 했을 때 실행
- 시점 시점부커 초기화 시작 지점까지변수를 참조할 수 없는 구간을 일시적 사각지대 라고 함 (TDZ)

### 15.2.4 전역 객체와 let

- let으로 선언한 전역 변수는 전역 객체의 프로터피가 아니다.

## 15.3 const

: 상수를 선언하기 위해 사용

### 15.3.1 선언과 초기화

- const로 선언한 변수는 반드시 선언과 동시에 초기화를 해야한다.

### 15.3.2 재할당 금지

### 15.3.3 상수

- 상수는 재할당이 금지된 변수를 말한다.
- 대문자로 선언해 사수임을 나타낸다.

### 15.3.4 const키워드와 객체

- 객체를 할당할 경우 값 변경 가능
- 재할당을 금지할 뿐 불변을 의미하지 않음

# 16장 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

- [[]]로 감쌈.

1. 내부슬롯 : 의사프로퍼티 (특성)
2. 내부 메서드 : 의사메서드 (동작, 기능)

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립트 객체

- JS엔진은 프로퍼티를 생성할 때 프로퍼티 어트리뷰트를 기본값으로 자동 정의.
- 직접 접근은 불가능 하지만 메서드를 사용해 간접적으로 확인 가능 => Object.getOwnPropertyDescriptor
- Object.getOwnPropertyDescriptor 메서드는 프로퍼티 디스크립터 객체 반환.
- 프로퍼티 디스크립터 객체 = 프로퍼티 어트리뷰트 정보를 제공하는 객체

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

### 16.3.1 데이터 프로퍼티

:키와 값으로 구성된 일반적인 프로퍼티
프로퍼티 어트리뷰트
| 프로퍼티 어트리뷰트 | 설명 |
|--------------------- |------------------------------------------------------------------------------------------------------------- |
| [[value]] | 프로퍼티 값의 변경 가능 여부, 불리언 값<br>키를 통해 값을 변경하면 [[Value]]에 값을 재할당. |
| [[writable]] | 프로퍼티 값의 변경 가능 여부, 불리언 값<br> [[writable]]가 false일 경우 [[Value]]값을 변경 할 수 없는 읽기 전용 프로퍼티가 됨. |
| [[Enumerable]] | 프로퍼티 열거 가능 여부, 불리언 값<br>[[Enumerable]]가 false일 경우 열거를 할 수 없음. |
| [[configurable]] | 프로퍼티 재정의 가능 여부, 불리언 값<br>[[configurable]]가 false일 경우 프로터티의 삭제, 어트리뷰트 값의 변경이 금지. <br> [[writable]] 이 true일 경우 [[value]] 변경과 [[writable]] 을 false로 변경은 허용|

### 16.3.2 접근자 프로퍼티

:접근자 함수로 구성된프로퍼티
프로퍼티 어트리뷰트
| 프로퍼티 어트리뷰트 | 설명 |
|--------------------- |------------------------------------------------------------------------------------------------------------- |
| [[get]] | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수|
| [[set]] |접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 |
| [[Enumerable]] | 데이터 프로퍼티와 동일|
| [[configurable]] | 데이터 프로퍼티와 동일|

## 16.4 프로퍼티 정의

: 프로퍼티를 추가하면서 프로퍼티 어트리뷰트 명시적으로 정의 or 기존 프로퍼티 프로퍼티 어트리뷰트 재정의

- Object.definedProperty 메서드로 하나의 프로퍼티 어트리뷰트 정의 가능
- Object.definedProperties 매서드로 여러 개의 프로퍼티 한 번에 정의 가능

## 16.5 객체 변경 방지

- 객체는 변경 가능한 값 => 재할당 없이 직접 변경 가능
- JS에서 객체의 변경을 방지하는 메서드

---

P = 프로퍼티

| 구분           | 메서드                   | P 추가 | P 삭제 | P 값 읽기 | P 값 쓰기 | P 어트리뷰트 재정의 |
| -------------- | ------------------------ | ------ | ------ | --------- | --------- | ------------------- |
| 객체 확장 금지 | Object.preventExtensions | X      | O      | O         | O         | O                   |
| 객체 밀봉      | Object.seal              | X      | X      | O         | O         | X                   |
| 객체 동결      | Object.freeze            | X      | X      | O         | X         | X                   |

### 16.5.1 객체 확장 금지

- 프로퍼티 추가 금지 => Object.preventExtensions
- 확장 가능 여부 => Object.isExtensible

### 16.5.2 객체 밀봉

- 읽기와 쓰기만 가능 => Object.seal
- 밀봉 여부 => Object.isSealed

### 16.5.3 객체 동결

- 읽기만 가능 => Object.freeze
- 동결 여부 => Object.isFrozen

### 16.5.4 불변 객체

- 위에 3가지는 얕은 변경 방지로, 직속 프로퍼티만 변경이 방지.
- 모든 프로퍼티에 freeze 메서드 호출. (재귀적으로 하면 쉬움)

# 17장 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

- 생성자 함수?
  - new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수.
- new 연산자와 함께 Object 생성자 함수 호출하면 빈 객체 생성 후 반환

## 17.2 생성자 함수

- 역할
  - (필수) 인스턴스 생성
  - (옵션) 생성된 인스턴스를 초기화

### 17.2.1 객체 리터널에 의한 객체 생성 방식의 문제점

- 직관적이고 간편하나 단 하나의 객체만 생성.
- 프로퍼티 구조가 동일함에도 매번 같은 프로퍼티와 메서드를 기술해야함.=> 여러 개 생성 시 비효율적.

### 17.2.2 생성자 함수에 의한 객채 생성 방식의 장점

- 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성.
- new와 함께 호출하면 생성자 함수로 동작.

**⭐this : 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기참조 변수.**

- this 바인딩은 함수 호출 방식에 따라 동적으로 결정.

| 함수 호출 방식  |              this 바인딩              |
| :-------------: | :-----------------------------------: |
|  일반 함수로서  |               전역객체                |
|   메서드로서    | 메서드를 호출한 객체 (마침표 앞 객체) |
| 생성자 함수로서 | 생성자 함수가(미래에) 생성할 인스턴스 |

### 17.2.3 생성자 함수의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩
   - 암묵적으로 인스턴스 생성 후 this에 바인딩
2. 인스턴스 초기화
   - 프로퍼티나 메서드를 추가하고 생성자 함수가 인스로 전달 받은 초기값을 초기화하거나 고정값 할당
3. 인스턴스 반환
   - 함수 내부에서 모든 처리가 끝나면 인스턴스가 바인딩된 this를 암묵적으로 반환
   - this가 아닌 다른 객체를 명시적 반환 => return 문에 명시한 객체가 반환
   - 명시적으로 원시 값 반환 => 암묵적으로 this반환
   - 생성자 함수 내부에서 return문을 반드시 생략.

### 17.2.4 내부 매서드 [[Call]],[[Construct]]

- 함수는 일반 객체와는 다름. => 일반 객체 호출X, 함수 호출O
- 객체는 내부 슬롯과 내부 메서드를 가지고 있음
- 함수는 일반 함수로서 호출되면 내부 메서드 `[[Call]]` 호출,
- 함수는 생성자 함수로서 호출되면 내부 메서드 `[[Construct]]`가 호출.
- `[[Call]]`을 갖는 함수 객체 = callable => 함수
- `[[Construct]]`를 갖는 함수 = constructor => 생성자 함수 호출 O
- `[[Construct]]`를 갖지 않는 함수 = Non-constructor => 생성자 함수 호출 X

### 17.2.5 constructor와 Non-constructor의 구분

- 함수 정의 방식에 따라 구분.
  - constructor : 함수 선언문, 함수 표현식, 클래스
  - Non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수

### 17.2.6 new 연산자

- new연산자와 함께 함수 호출 O => 생성자 함수
  - `[[Construct]]`가 호출. constructor이어야 한다
- new연산자와 함께 함수 호출 X => 일반 함수
  - `[[Call]]` 이 호출
- 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력

### 17.2.7 new.target = 메타 프로퍼티

- 생성자 함수가 new연산자 없이 호출 방지를 위해 사용.
- this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용
- 함수 내부에서 사용 시 new연산자와 함께 호출 되었는지 확인 가능
- new연산자와 함께 생성자 함수로서 호출 => 함수 자신을 가르킴
- new연산자 없이 생성자 함수로서 호출 => undefined

# 18장 함수와 일급 객체

## 18.1 일급 객체

= 객체와 동일하게 사용 가능

1. 무명의 리터럴로 생성 = 런타임에 생성이 가능
2. 변수나 자료 구조에 저장 가능
3. 함수의 매개변수에 전달 가능 (콜백함수)
4. 함수의 반환값으로 사용 가능 (재귀함수)

## 18.2 함수 객체의 프로퍼티

- 함수도 프로퍼티를 가질 수 있음
- console.dir로 확인 가능

### 18.2.1 arguments 프로퍼티

- arguments 프로퍼티 값 = arguments 객체
- argument 객체
  - 가변인자함수 구현에 유용
  - 함수 외부 참조 X
  - 유사배열 객체

### 18.2.2 caller 프로퍼티

### 18.2.3 length 프로퍼티

- 함수를 정의할 때 선언한 매개변수의 개수
  - arguments객체의 length => 인자의 개수
  - 함수 객체의 length => 매개변수의 개수

### 18.2.4 name 프로퍼티

- 함수이름을 나타냄

### 18.2.5 **proto** 접근자 프로퍼티

- 모든 객체는 `[[prototype]]` 내부 슬롯 존재 = 상속을 구현하는 프로토타입 객체를 가르킴
- **proto** 프로퍼티는 `[[prototype]]` 내부 슬록이 가리키는 프로토 타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

### 18.2.6 prototype 프로퍼티

- 생성자 함수로 호출할 수 있는 객체 => constructor만이 소유하는 프로퍼티
- 생성자 함수로 호출 될 때 생성자 함수가 생성할 인스턴스의 프로토 타입 객체를 가르킴
