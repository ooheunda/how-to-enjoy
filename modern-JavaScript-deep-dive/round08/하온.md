# 23장 실행 컨텍스트

## 2 소스 코드의 평가와 실행

: 소스 코드는 **평가**와 **실행**의 과정으로 나뉨.

- 평가 과정
  - 실행 컨텐스트 생성
  - 변수, 함수 등의 선언문만 먼저 실헹 => 생성된 변수or함수 식별자를 키로 스코프에 등록
- 실행 과정
  - 런타임 시작.
  - 변수나 함수의 참조를 실행컨텍스트가 관리하는 스코프에서 검색하여 취득

```javascript
var x;
x = 1;
```

1. 평가과정

- `var x`을 실행 -> x를 실행 컨텍스트가 관리하는 스코프에 등록 -> undefined로 초기화

2. 실행과정

- `x = 1` 실행 -> x가 선언된 변수인지 실행 컨텍스트가 관리하는 스코프에서 확인 -> 1 할당 -> 실행 컨텍스트에서 관리

## 3 실행 컨텍스트의 역할

- 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내무 메커니즘
- 식별자와 스코프는 렉시컬 환경으로 관리.
- 코드 실행 순서는 실행 컨텍스트 스택으로 관리

## 4 실행 컨텍스트 스택

```javascript
const x - 1;

function foo(){
    const y = 2;

    function bar(){
        const z = 3;
        console.log(x + y + z);
    }
    bar()
}
foo()
```

![alt text](https://user-images.githubusercontent.com/80154058/142868095-b75bf72d-9abc-4856-adb6-9efe2294e72c.png)

1. `전역` 코드 평가와 실행

- `전역` 실행 컨텍스트 생성 후 스택에 푸쉬.
- X와 `foo` 전역 실행 컨텍스트에 등록
- x에 값 할당, `foo` 호출

2. `foo`함수 코드의 평가와 실행

- 코드의 제어권이 `foo`함수 내부로 이동
- `foo` 함수 실행 컨텍스트 생성 후 스택에 푸쉬.
- y와 bar가 함수 실행 컨텍스트에 등록
- y 값 할당, `bar` 호출

3. `bar` 함수 코드의 평가와 실행

- 제어권이 `bar` 함수 내부로 이동
- `bar` 함수 실행 컨텍스트 생성 후 스택에 푸쉬.
- z가 `bar` 함수 실행 컨텍스트에 등록
- z 할당 후 console.log 메서드 호출

4. foo 함수로 복귀
5. 전역 코드로 복귀

실행 컨텍스트 최상위에 존재하는 실행 컨텍스트를 **실행중인 실행 컨텍스트** 라고 부름

## 5 렉시컬 환경

: 식별자와 스코프를 관리

- 키와 값을 값는 객체 형태의 스코프를 생성
- 식별자를 키로 등록, 식별자에 바인딩된 값을 관리

1. 환경 레코드

- 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소

2. 외부 렉시컬 환경에 대한 참조

- 상위 스코프를 가르킴. (상위 스코프는 렉시컬 환경)

## 6 실행 컨텍스트의 생성과 식별자 검색 과정

```javascript
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); // 42
```

### 6.1 전역 객체 생성

### 6.2 전역 코드 평가

- 전역 실행 컨텍스트 생성
- 전역 렉시컬 환경 생성
  - 전역 환경 레코드 생성
    - 객체 환경 레코드 생성
    - 선언적 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

#### 1) 전역 실행 컨텍스트 생성

- 전역 실행 컨텍스트를 생성 후 실행 컨텍스트 스택에 push

#### 2) 전역 렉시컬 환경 생성

- 전역 렉시컬 환경 생성 후 전역 실행 컨텍스트에 바인딩

**2-1) 전역 환경 레코드 생성**

- 객체 환경 레코드 생성

  - var로 선언한 전역 변수/ 함수 선언문으로 선언한 전역 함수

  => BindingObject를 통해 전역 객체의 프로퍼티/ 메서드

- 선언적 환경 레코드 생성
  - let, const 키워드로 선언한 전역변수는 이곳에 등록되고 관리
- this 바인딩
  - 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬록에 바인딩 됨. 보통은 전역 객체가 바인딩.
- 외부 렉시컬 환경에 대한 참조 결정
  - 상위 스코프를 가리킴. => 스코프 체인 구현

### 6.3 전역 코드 실행

- 전역변수 x와 y에 값이 할당, foo함수 호출.
- 식별자 결정
  - 식별자는 같은 이름으로 다른 스코프에 존재 할 수 있음
  - 현재 스코프에서 식별자 검색 -> 상위 스코프에서 식별자 검색 -> 상위 스코프에서 식별자 검색

### 6.4 foo 함수 코드 평가

- 함수 실행 컨텍스트 생성
- 함수 렉시컬 환경 생성
  - 함수 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

이후

foo 함수 코드 실행 -> bar 함수 코드 평가, 실행, 종료 -> foo 함수 코드 종료 -> 전역 코드 종료

# 27장 배열

## 1. 배열이란

: 값을 순차적으로 나열한 자료 구조

- 배열이 가지고 있는 값 => 요소
- 요소는 인덱스를 가짐. 0 부터 시작.
- 요소 접근 -> arr[0] // 대괄호로 접근

## 2. JS 배열은 배열이 아니다

- 자료구조에서 말하는 배열
  - 동일한 크기의 메모리 공간이 빈틈 없이 연속적으로 나열된 자료구조
- 밀집 배열 => 요소가 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접
- 희소 배열 => 요소가 연속적으로 이어져 있지 않음

## 4. 배열 생성

### 4.1 배열 리터럴

- 0개 이상의 요소를 쉼표를 구분하여 대괄호로 묶음

```javascript
const arr1 = [1, 2, 3];
const arr2 = [1, , 3]; // 희소 배열
```

### 4.2 Array 생성자 함수

```javascript
const arr = new Array(1, 2, 3);
const arr = new Array(3); // 인수가 1개이고 숫자이면 길이로 인식 -> [empty * 3]
```

### 4.3 Array.of

- 전달된 인수를 요소로 갖는 배열 생성
- 인수가 1개이고 숫자여도 인수를 요소로 가짐

```javascript
Arrat.of(3); // [3]
```

### 4.2 Array.from

- 유사배열 객체 or 이터러블 객체를 인수로 전달받아 배열로 변환 후 반환

```javascript
Arrat.from({ length: 2, 0: 'a', 2: 'b' }); // ['a','b']
Arrat.from('hello'); // ['h','e','l','l','o']
```

## 5. 배열의 요소 참조

- [] 사용

## 7. 요소의 삭제

- splice 사용
