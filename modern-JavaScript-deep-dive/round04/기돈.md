## 12장

- 함수: 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것, 객체

- 함수 사용 이유
    - 코드의 재사용
    - 유지보수의 편의성
    - 코드의 신뢰성
    - 코드의 가독성

- 함수 리터럴
    - 구성 요소: function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체

    - 함수 이름
        - 식별자
        - 함수 몸체 내부에서만 참조 가능
        - 이름 있으면 기명 함수, 없으면 무기명 함수
    - 매개 변수 목록
        - 순서가 의미 있음
        - 함수 몸체 내부에서 변수 취급
    - 함수 몸체
        - 코드 블록
        - 함수 호출에 의해 실행

- 함수 정의 방법
    - 함수 선언문
        ```js
        function add(x,y){
            return x + y;
        }
        ```
    - 함수 표현식
        ```js
        var add = function (x,y) {
            return x + y;
        }
        ```
    - function 생성자 함수
        ```js
        var add = new Function('x','y', 'return x + y')
        ```
    - 화살표 함수
        ```js
        var add = (x,y) => x + y;
        ```

- 함수 생성 시점과 호이스팅
    - 함수 선언문: 런타임 이전에 함수 객체를 생성
    - 함수 표현식: 런타임 이전에 선언, 값은 undefined, 런타임 이후에 함수 객체 생성
    - 함수 표현식을 사용하는게 더 적절함
    
        **함수 선언식은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 규칙에 위배됨**

- 함수 호출 시 유의점
    - 함수 호출 시, 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.

        **>> 인수의 기본값을 할당해주는 것이 필요**
    - 매개변수의 타입을 사전에 정의할 수 없다.

        **>> typeof 를 통해 인수의 타입을 확인해주는 것이 필요**
- return 값 뒤에 줄바꿈이 있으면, 자동 세미콜론이 생성되어 아래 값은 무시된다.

- 즉시 실행 함수
    - 함수 실행 시, 그룹 연산자 ()로 묶어서 사용, 다시 호출할 수는 없다.
    - 그룹 연산자로 묶는 이유: 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서이다.

- ES6부터는 함수 정의는 문이 위치할 수 있으면 어디든지 가능하다.

- 콜백 함수
    - 함수의 매개변수로 다른 함수에 전달되는 함수
    - 콜백 함수를 받는 함수를 고차 함수라고 부름
    - 함수를 호출하지 않고, 전달하는 것이 일반적
    - 고차 함수 내부에만 호출되는 경우, 익명 함수 리터럴로 정의하면서 고차 함수로 전달

- 순수 함수와 비순수 함수
    - 순수 함수 : 부수 효과가 없는 함수 (외부의 요소를 변화시키기 않는 함수)
    - 비 순수 함수 : 부수 효과가 있는 함수 (외부의 요소 - 리터럴 을 변경하는 함수)

    - 비 순수 함수의 사용 시 유의점

        **외부 요소의 상태 변화를 추적하기 어렵다.**
        **부수 효과를 최소화해서 불변성을 지키는 것이 중요하다.**
    

## 13장
- 스코프 (유효범위)
  - 위치에 따라 유효범위가 결정된다. 네임스페이스
    |구분|설명|스코프|변수|
    |---|---|---|---|
    |전역|코드의 가장 바깥 영역|전역 스코프|전역 변수|
    |지역|함수 몸체 내부|지역 스코프(함수 내부)|지역 변수|

## 14장

## 질문

161쪽 예제 12 - 08 **함수 리터럴을 피연산자**로 사용하면 함수선언문이 아니라 함수 리터럴 표현식으로 해석 이 무슨 말? 선언 이름 => 식별자 => 메모리 내 식별자 => 함수 데이터 인데, 예제와 같이 하면 식별자가 없이 메모리에 저장된다는 말인가요?

175쪽 원시 값은 "값에 의한 전달", 객체는 "참조에 의한 전달" 이라는 말이 식별자와 값의 차이인가요?

190쪽 var는 무조건 global은 아닌건지...

## 퀴즈

1번 : 함수의 사용 이유 4가지
<details>
    <summary>정답</summary>
    <ul>
        <li>코드의 재사용</li>
        <li>유지보수의 편의성</li>
        <li>코드의 신뢰성</li>
        <li>코드의 가독성</li>
    </ul>
</details>

2번 : 

    ```js
    var x=1;

    function foo(){
        var x=10;
        bar();
    }

    function bar(){
        console.log(x);
    }

    foo() // 1)
    bar() // 2)
    ```
    
<details>
    <summary>정답</summary>
    <div>자바스크립트는 렉시컬(lexical) 스코프</div>
    <div>호출 위치가 아닌, 정의된 위치에서만 동작된다.</div>
    <ol>
        <li>1</li>
        <li>1</li>
    </ol>
</details>
