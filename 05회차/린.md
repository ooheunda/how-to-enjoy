# 14. 전역 변수의 문제점
### 변수의 생명주기
- 지역 변수의 생명 주기는 함수의 생명주기와 일치한다.
- 호이스팅은 스코프를 단위로 동작한다.
- var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명주기와 일치한다.

### 전역변수의 문제점
- 암묵적 결합: 모든 코드가 전역 변수을 참조하고 변경할 수 있다.
- 긴 생명주기: 전역변수는 생명주기가 길다.
- 스코프 체인 상에서 종범에 존재: 전역변수의 검색 속도가 가장 느리다.
- 네임스페이스 오염: 파일이 분리되어있어도 하나의 전역 스코프를 공유한다.

### 전역변수의 사용을 억제하는 방법
- 즉시 실행 함수 - 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역변수가 된다.
- 네임스페이스 객체 - 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.
- 모듈패턴 - 클로저를 기반으로 동작, 전역변수의 억제는 물론 캡슐화까지 구현할 수 있다.
- ES6 모듈 - ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

# 15. let, const 키워드와 블록 레벨 스코프
### var 키워드로 선언한 변수의 문제점
- 변수 중복 선언 허용
- 함수 레벨 스코프 - 함수의 코드블록외에는 함수 외부의 어떤 코드블록 내에서 선언해도 모두 전역변수가 된다.(ex. for문, if뮨 try/catch...등)
- 변수 호이스팅

### let 키워드
- 변수 중복 선언 금지
- 블록 레벨 스코프 - 모든 코드블록을 지역 스코프로 인정한다.
- 변수 호이스팅 - let키워드로 선언한 변수는 선언과 초기화 단계가 분리되어 진행된다. 초기화가 실행되기 이전에 변수에 접근하려고 하면 참조에러가 발생한다. 호이스팅이 발생하지 않는 것은 아니다.
- 전역 객제와 let - let으로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다. window.변수식별자 로 접근할 수 없다.

### const 키워드
- 선언과 초기화 - const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야 한다. 그렇지 않으면 문법에러가 발생한다.
- 재할당 금지 - const 키워드로 선언한 변수는 재할당이 금지된다.
- 상수 - 재할당이 금지된 변수를 말한다. 그러나 재할당을 금지할 뿐, "불변"을 의미하지는 않는다. 아래에서 설명
- const 키워드와 객체 - const키워드로 선언된 변수에 원시값을 할당한 경우 값을 변경할 수 없지만, 객체를 할당한 경우 값을 변경할 수 있다.
  
# 16. 프로퍼티 어트리뷰트
### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
- Object.getOwnPropertyDescriptor 메서드는 호출하면 프로퍼티 어트리뷰트정보를 제공한다. 이때 결과값으로 반환하는 (프로퍼티 어트리뷰트의 정보를 담은)객체가 프로퍼티 디스크립터 객체이다.

### 데이터 프로퍼티와 접근자 프로퍼티
#### 데이터 프로퍼티 
- 키와 값으로 구성된 일반적인 프로퍼티다.
- 프로퍼티 어트리뷰트
  1. [[Value]]: 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다.
  2. [[Writable]]: 프로퍼티 값의 변경 가능 여부를 나타낸다.
  3. [[Enumerable]]: 프로퍼티의 열거 가능 여부를 나타낸다.
  4. [[Configurable]]: 프로퍼티의 재정의 기능 여부를 나타낸다.
  
#### 접근자 프로퍼티
- 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.
- 프로퍼티 어트리뷰트
  1. [[Get]: 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수다. = getter함수
  2. [[Set]: 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. = setter함수
  3. [[Enumerable]]: 프로퍼티의 열거 가능 여부를 나타낸다.
  4. [[Configurable]]: 프로퍼티의 재정의 기능 여부를 나타낸다.

### 프로퍼티 정의
- Object.defineProperty 메서드를 사용해서 프로퍼티의 어트리뷰트를 정의할 수 있다.
- Object.defineProperties 메서드를 사용하면 여러개의 프로퍼티를 한번에 정의할 수 있다.

### 객체 변경 방지
- 우리는 객체의 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티 값을 갱신할 수 있으며, Object.defineProperty를 사용해 프로퍼티 어트리뷰트를 재정의할 수도 있다. 이러한 객체의 변경을 방지하는 메서드들도 있다.
  1. 객체 확장 금지 - Object.preventExtensions = 프로퍼티 추가를 금지한다. Object.isExtensible메서드로 확장가능한 객체인지 확인할 수 있다.
  2. 객체 밀봉 - Object.seal = 객체를 밀봉해서 읽기와 쓰기만 가능하게 한다. 프로퍼티 추가와 삭제 모두 금지, 갱신은 가능. 어트리뷰트 재정의도 금지. Object.isSealed메서드로 밀봉된 객체인지 확인할 수 있다.
  3. 객체 동결 - Object.freeze = 객체를 동결해서 읽기만 가능하게 한다. 프로퍼티 추가와 삭제, 값 갱신, 어트리뷰트 재정의 금지. Object.isFrozen메서드로 동결된 객체인지 확인할 수 있다.
- 이런 메서드들은 얕은 변경방지라서 중첩객체까지는 영향을 주지 못한다. 중첩객체까지 동력하여 변경이 불가능한 불변객체를 구현하려면 모든 프로퍼티에 대해 재귀적으로 Object.freeze메서드를 호출해야한다.
  
# 17. 생성자 함수에 의한 객체 생성
### Object 생성자 함수
- const 변수이름식별자 = new Object(); >> 빈 객체 생성
### 생성자 함수 
- 객체 리터럴에 의한 객체 생성 방식의 문제점: 직관적이고 간편하지만 단 하나의 객체만 생성한다. 동일한 프로퍼티를 갖는 객체를 여러개 생성해야하는 경우에는 비효율적이다.
- 생성자 함수에 의한 객체 생성 방식의 장점: 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 
- 생성자 함수의 인스턴스 생성과정
  1. 인스턴스 생성과 this바인딩
  2. 인스턴스 초기화
  3. 인스턴스 반환
- 내부 메서드[[Call]과 [[Construct]]
- constructor와 non-constructor의 구분
  - constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
  - non-constructor: ES6 메서드, 화살표 함수
  - 함수가 어디에 할당되어 있는지가 아니라 함수 정의 방식에 따라 constructor와 non-constructor를 구분한다.
- new 연산자
  - new연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 단, new연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이어야 한다.
  - 생성자 함수는 일반적으로 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 해야한다.
- new.target
  - new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. 일반함수로서 호출된 함수 내부의 new.target은 undefined다.
  
# 18. 함수와 일급 객체
### 일급 객체
- 다음 조건을 만족하는 객체를 일급 객체라고 한다.
  1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
  2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
  3. 함수의 매개변수에 전달할 수 있다.
  4. 함수의 반환값으로 사용할 수 있다.
  자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체다.
### 함수 객체의 프로퍼티
- arguments, caller, length, name, prototype는 모두 함수 객체의 데이터 프로퍼티로, 일반 객체에는 없는 함수 객체 고유의 프로퍼티다.
  #### arguments 프로퍼티
    - 함수 객체의 arguments프로퍼티 값은 arguments객체다.
    - arguments객체는 함수 호출시 전달된 인수들의 정보를 담고 있는 순회가능한 유사배열 객체이고, 함수 내부에서 지역변수처럼 사용된다.
    - Function.arguments 같은 사용법은 권장되지 않음. 함수 내부에서 지역변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다.
    - arguments객체는 매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용하다.
  #### caller 프로퍼티
    - 함수 객체의 callar 프로퍼티는 함수 자신을 호출한 함수를 가리킨다.
    - 비표준 프로퍼티임. 관심없다면 지나쳐라.
  #### length 프로퍼티
    - 함수 객체의 length 프로퍼티는 함수를 정의할 때, 선언한 매개변수의 개수를 가리킨다.
    - arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개변수의 개수를 가리킨다.
  #### name 프로퍼티
    - 함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.
  #### __proto__ 접근자 프로퍼티
    - 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 이 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.
    - __proto__ 프로퍼티는 [[Prototype]]내부 슬롯이 가리키는 프로토 타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다.
  #### prototype 프로퍼티
    - prototype 프로퍼티는 constructor만이 소유하는 프로퍼티다. 함수가 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.
