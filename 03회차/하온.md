# 9장 타입 변환과 단축 평가

## 9.1 타입변환이란?

: 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성.
🚨두가지 타입 변환 모두 기존 원시 값은 변하지 않음 `num`은 여전히 `number` `10` 임

## 9.2 암묵적 타입 변환

: 자바 스크립트 엔진에 의해 암묵적으로 원시 타입 중 하나로 자동 변환

```javascript
let num = 10;
let str = num + "";
console.log(typeof str, str); // string 10
```

JS 엔진은 표현식을 평가 할 때 에러를 발생시키지 않기 위해 암묵적 타입 변환을 통해 표현식을 평가한다.

### 9.2.1 문자열 타입으로 변환

피연산자중 문자열이 있으므로 위에서 +연산자는 문자 연결 연산자로 동작한다.

```javascript
1 + "2"; // "12"
```

### 9.2.2 숫자 타입으로 변환

:산술 연산자의 모든 피연산자는 코드 문맥상 숫자여야 하므로 암묵적으로 숫자로 변환한다

```javascript
1 - "1"; // 0
1 * "10"; // 10
```

### 9.2.3 불리언 타입으로 변환

: 조건식의 평가 결과를 불리언 타입으로 암묵적으로 변환한다.

```javascript
if ("")    // X
if (true)  // O
if (0)     // X
if ("a")   // O
if (null)  // X
```

불리언값으로 평가되어야 할 문맥에 불리언 타입이 아닌 값을 Truthy, Falsy로 암묵적 타입 변환을 한다.
false로 평가 되는 값

- false
- undefined
- null
- 0, -0,
- NaN
- ""

## 9.3 명시적 타입 변환 = 타입 캐스팅

: 개발자가 의도적으로 타입 변경하는 방법

### 9.3.1 문자열 타입으로 변환

1. String 함수를 new 연산자 없이 호출하기
2. toString() 메서드를 사용하기
3. 문자열 연결 연산자 이용하기

```javascript
// 1. String 함수
String(10)(
  // "10"
  // 2. toString() 메서드를 사용하기
  10
).toString(); // "10"
// 3. 문자열 연결 연산자 이용하기
1 + ""; // "1"
```

### 9.3.2 숫자 타입으로 변환

1. Number 함수를 new 연산자 없이 호출하기
2. parseInt, paeseFloat 메서드를 사용하기 (문자-> 숫자만 가능)
3. 단항 산술 연산자 + , 산술 연산자 \* 이용

```javascript
// 1. Number 함수를 new 연산자 없이 호출하기
Number("10"); // 10
// 2. parseInt, paeseFloat 메서드를 사용하기 (문자-> 숫자만 가능)
parseInt("10"); // 10
paeseFloat("10.23") + // 10.23
  // 3. 단항 산술 연산자 + , 산술 연산자 * 이용
  "10"; // 10
"10" * 1; // 10
```

### 9.3.3 불리언 타입으로 변환

1. Boolean 생성자 함수를 new 연산자 없이 호출하기
2. !(부정 논리 연산자) 두 번 사용

```javascript
// 1. Boolean 생성자 함수를 new 연산자 없이 호출하기
Boolean(""); // false
Boolean("x"); // true
// 2. !(부정 논리 연산자) 두 번 사용
!!""; // false
!!"x"; // true
```

## 9.4 단축평가

: 표현식을 평가하는 도중에 평가 결과가 확정 난 경우 나머지 평과 과정을 생략 하는 것.

### 9.4.1 논리연산자

1. && 논리곱

- 두 개의 피연산자가 모두 true일 때 True 반환
- 어떤 조건이 Truthy 값일 때 무언가를 해야한다면 &&로 if문 대체가능

```javascript
"cat" && "dog"; // dog
```

```javascript
let done = true;
let msg = "";
/** if문 사용 **/
if (doen) msg = "완료";
/** 논리곱 사용 **/
msg = done && "완료";
```

2. || 논리합

- 둘 중 하나의 피연산자가 true일 때 True 반환
- 어떤 조건이 Falsy 값일 때 무언가를 해야한다면 ||로 if문 대체가능

```javascript
"cat" || "dog"; // cat
```

```javascript
let done = false;
let msg = "";
/** if문 사용 **/
if (!doen) msg = "미완료";
/** 논리합 사용 **/
msg = done || "미완료";
```

### 9.4.2 옵셔널 체이닝 연산자

: 좌항의 피연산자가 null / undefined일 경우 undefined 반환 그렇지 않으면 우항의 프로퍼티 참조

- ?. 사용
- &&으로 사용도 가능하지만 0이나 "" 경우에는 객체로 평가 될 때도 있음.

```javascript
let elem = null;
let value = elem?.value; // value는 undefined
```

### 9.4.3 null 병합 연산자

: 좌항의 피연산자가 null / undefined일 경우 우항의 피연산자를 반환. 그렇지 않으면 좌항의 피연산자 반환

- ?? 사용
- ||으로 사용도 가능하지만 0이나 "" 경우에는 객체로 평가 될 때도 있음.
- 변수에 기본값을 설정할 때 유용

```javascript
let foo = null ?? "default string"; // foo는 default string
```

# 10장 객체 리터럴

## 10.1 객체란?

:원시 값을 제외한 나머지 값은 모든 것. 0개 이상의 프로퍼티로 구성된 집합. 키와 값으로 구성.

- 프로퍼티의 값이 함수일 경우 메서드라고 한다.
- 프로퍼티 : 객체의 상태를 나타내는 값.
- 메서드 : 프로퍼티를 참조하고 조작할 수 있는 동장.

## 10.2 객체 리터럴에 의한 객체 생성

- {}내에 0개 이상의 프로퍼티를 정의. 변수에 할당 되는 시점에 JS엔진은 객체 리터럴을 해석해 객체 생성.
- 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음. => 닫는 중괄호 뒤에 세미콜론 붙이기.

## 10.3 프로퍼티

: 객체는 프로퍼티의 집합이며 프로퍼티는 키와 값으로 구성 된다.

- 프로퍼티 키
  - 식별자 역할로, 빈 문자열을 포함하는 모든 문자열 또는 심벌 값 사용 가능하다.
  - 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 붙여야 한다.
  - 문자열 또는 문자열로 표현할 수 있는 표현식을 사용해 동적 생성이 가능 => 대괄호로 묶어야 한다.
  - 중복 선언이 덮어씌어진다.
- 프로퍼티 값
  - Js에서 사용 가능한 모든 값을 사용 가능하다.

## 10.4 메서드

: 프로퍼티 값이 함수일 경우를 말한다. => 객체에 묶여있는 함수.

```javascript
var circle = {
    radius : 5      // 프로퍼티
    gerDiameter : function(){       // 메서드
        return 2 * this.radius;
    }
}
```

## 10.5 프로퍼티 접근

1. 마침표 표기법 (dot notation)
2. 대괄호 표기법 (bracket notation)

```javascript
var person = {
  name: "Lee",
};
/** 마침표 표기법**/
person.name;
/** 대괄호 표기법**/
person["name"];
```

🚨대괄표 표기법 사용 시 반드시 따옴표로 감싼 문자열 이어야 한다.

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

## 10.9.1 프로퍼티 축약 표현

: 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키 생략 가능

```javascript
let x=1, y=2
const obj{
    x,      // x : 1
    y       // y : 2
}
```

## 10.9.2 계산된 프로퍼티 이름

: 문자열 또는 문자열로 타입 변환 할 수 있는 값으료 평가되는 표현식을 사용해 프로퍼티 값을 동적으로 생성할 수 있다.

```javascript
// ES5
var prefix = "prop";
var i = 0;
var obj = {};

obj["prefix" + "-" + ++i] = i; // prop-1 : 1
obj["prefix" + "-" + ++i] = i; // prop-2 : 2
obj["prefix" + "-" + ++i] = i; // prop-3 : 3
// ES6
const prefix = "prop";
let i = 0;
var obj = {
  [`${prefix} - ${++i}`]: i, // prop-1 : 1
  [`${prefix} - ${++i}`]: i, // prop-2 : 2
  [`${prefix} - ${++i}`]: i, // prop-3 : 3
};
```

## 10.9.3 메서드 축약 표현

function 키워드 생략 가능하다.

# 11장 원시 값과 객체의 비교

## 11.1 원시값

### 11.1.1 변경 불가능한 값

: 원시타입의 값은 변경 불가능 한 값이다. => 읽기 전용

- 변수가 참조하던 메모리 공간의 주소가 변경 된 이유는 원시 값이 변경 불가능 한 값이기 때문이다 => 이러한 특성을 불변성 이라고 한다.

### 11.1.2 문자열과 불변성

: 문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정 된다.

- 재할당 시 참조하는 메모리 주소가 바뀐것이지 기존에 있던 값이 바뀌는게 아님
- 유사 배열 객체
  - 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 말한다.

### 11.1.3 값에 의한 전달

: 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 할당되는 변수의 운시 값이 복사되어 전달이 된다.

- 두 변수의 값은 80으로 같지만 다른 메모리 공간에 저장된 별개의 값이다. => 서로 간섭 X

## 11.2 객체

: 프로퍼티의 개수가 정해지지 않았으며 동적으로 추가 되고 삭제 할 수 있다 => 메모리 공간의 크기를 사전에 정해 둘 수 없다.

### 11.2.1 변경 가능한 값

객체 타입의 값은 변경이 가능한 값이다.

- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근 할 수 있다.

### 11.2.2 참조에 의한 전달

: 객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사 되어 전달 된다 => 참조에 의한 전달.

- 두 개의 식별자가 하나의 객체를 공유한다.
  => 하나의 식별자를 수정하게 되면 다른 식별자도 수정이 된다.
